# File Patterns
ALL := *.m;

##

add(params) = detailed_data => """ struct with fields storing high dimensional
data, i.e. dependent on dimension `H`. This data is necessary for detailed
simulations, construction of online matrices, reduced_data and reconstruction of
reduced simulations. """;

add(params) = model => """ structure with control fields for
  - model specification (e.g. function pointers to boundary and initial data functions),
  - model discretization (fv/ldg, implicit/explicit, etc...),
  - model parametrization (definition of `\mu` vector),
  - reduced basis generation and
  - post-processing.
  .
  The \c model is the first argument of many functions. See @ref models for examples.
  """;

add(params) = model_data => """ struct with `H`-dimensional data, that is
used in several detailed simulation routines but can be generated once from the
analytical model specification. E.g. the grid is stored here. """;

add(params) = reduced_data => """ struct with online matrices and other
low-dimensional, i.e. `N`-dimensional data fields. """;

add(params) = plot_params => """ parameter structure controlling
the output of the plot.  For time dependent problems
'plot_params' are often passed to plot_element_data() and
plot_sequence(). """;

add(params) = sim_data => """ matlab struct with simulation data
generated e.g. by detailed_simulation() or rb_reconstruction()
methods. """;

add(params) = grid => """ an object of type gridbase
 """;

# default documentation
add(fields) =
(
  model.T => """ end time for evolution problems """,
  model.t => """ variable storing timestep currently processed """,
  model.nt => """ number of time steps for evolution discretizations """,
  model.dt => """ time step size for evolution discretizations """,
  model.mu_names => """ cell array of field names of the 'model' structure that
    correspond to the components in the parameter vector 'model.mu' """,
  model.decomp_mode => """ flag indicating the operation mode of the function:
       - 0 (complete)     : no affine parameter dependence or decomposition
       is performed.
       - 1 (components)   : for each output argument a cell array of output
       matrices is returned representing the `q`-th component independent
       of the parameters given in 'mu_names'.
       - 2 (coefficients) : returns a vector where each coordinate represents
       the `q`-the coefficient `\sigma_{\cdot}^{q}(\mu)` dependent on
       the parameters given in 'mu_names'.
       """,
  model.mu => """ the parameter vector `\mu`. It should only be set via
    the function 'set_mu'. """,
  model.mu_names => """ a string array containing the symbolic names of the
    parameter vector `\mu` """,
  model.mu_ranges => """ matrix storing the admissable ranges for parameter
    vector components. Each two dimensional column vector represents a range
    for a component specified by 'model.mu_names'. """,
  model.get_inner_product_matrix => """ function 'W=f(model_data)' returning the
    mass matrix `W` for inner product computation
    `\langle u,v \rangle = u^t W v`. """,
  model.get_dofs_from_sim_data => """ function 'u=f(sim_data)' returning
    degrees of freedom stored in a 'sim_data' structure.""",
  model.get_rb_from_detailed_data => """ function 'RB=f(detailed_data)'
    returning the reduced basis vectors stored in a 'detailed_data' structure.
    """,
  model.set_rb_in_detailed_data => """ function
    'detailed_data=f(detailed_data, newRB)' updating the reduced basis vectors
    stored in 'detailed_data' by assigning them to 'newRB'.""",
  model.plot_sim_data => """ problem specific function
    performing the plot of the simulation results. """,
  model.debug => """ flag indicating wether debug output shall be turned on """,
  model.verbose => """ flag indicating the verbosity level of informative
    output """,
  model.newton_solver => """ boolean flag indicating whether the numerical
    scheme includes non-linear equations that need to be solved by a Newon
    scheme """,
  model.inner_product_matrix_algorithm => """ function pointer to a function
    computing a inner product matrix `W`, such that `u^t W v = <u, v>`. An
    example is fv_inner_product_matrix(). """
);

add(fields) =
(
  grid.X => """ vector of vertex `x`-coordinates. """,
  grid.Y => """ vector of vertex `y`-coordinates. """,
  grid.VI => """ matrix of vertex indices: 'VI(i,j)' is the
    global index of the 'j'-th vertex of element 'i' """,
  grid.CX => """ vector of centroid `x`-values """,
  grid.CY => """ vector of centroid `y`-values """,
  grid.NX => """ 'NX(i,j) = ' `x`-coordinate of unit outer
    normal of edge from el 'i' to NB 'j' """,
  grid.NY => """ 'NY(i,j) = ' `y`-coordinate of unit outer
    normal of edge from el 'i' to NB 'j' """,
  grid.ECX => """ 'ECX(i,j) = ' `x`-coordinate of midpoint of
    edge from el 'i' to NB 'j' """,
  grid.ECY => """ 'ECY(i,j) = ' `y`-coordinate of midpoint of
    edge from el 'i' to NB 'j' """,
  grid.SX => """ vector of `x`-coordinates of point `S_i` (for
    rectgrid: identical to centroids) """,
  grid.SY => """ vector of `y`-coordinate of point `S_j` (for
    rectgrid: identical to centroids) """,
  grid.ESX => """ 'ESX(i,j) = ' `x`-coordinate of point `S_{ij}`
    on edge between element 'i' and neighbor 'j' """,
  grid.ESY => """ 'ESY(i,j) = ' `y`-coordinate of point `S_{ij}`
    on edge between element 'i' and neighbor 'j' """,
  grid.DS => """ 'DS(i,j) = ' distance from `\bar{S_i S_j}`
    for boundary elements, this is the distance to the
    reflected element (for use in boundary treatment) """,
  grid.nelements => """ number of elements """,
  grid.nvertices => """ number vertices """,
  grid.nneigh => """ number of neighbours of each element """,
  grid.A => """ vector of element areas """,
  grid.Ainv => """ vector of inverted element areas """
);

add(fields) =
(
  params.T => """ end time for evolution problems """,
  params.t => """ variable storing timestep currently processed """,
  params.nt => """ number of time steps for evolution discretizations """,
  params.dt => """ time step size for evolution discretizations """,
  params.mu_names => """ cell array of field names of the 'params' structure that correspond to the
  components in the parameter vector 'params.mu'
  """,
  params.decomp_mode => """ flag indicating the operation mode of the function:
       - 0 (complete)     : no affine parameter dependence or decomposition
       is performed.
       - 1 (components)   : for each output argument a cell array of output
       matrices is returned representing the `q`-th component independent
       of the parameters given in 'mu_names'.
       - 2 (coefficients) : returns a vector where each coordinate represents
       the `q`-the coefficient `\sigma_{\cdot}^{q}(\mu)` dependent on
       the parameters given in 'mu_names'.
       """,
  params.mu => """ the parameter vector `\mu`. It should only be set via
  the function 'set_mu'. """,
  params.debug => """ flag indicating wether debug output shall be turned on """,
  params.verbose => """ flag indicating the verbosity level of informative
  output """
);

add(fields) = (
  model_data.grid => """ a structure containing geometry information of a
  mesh used for discretizations """
);

add(fields) = (
  detailed_data.grid => """ a structure containing geometry information of a
  mesh used for the discretizations """
);

glob = rbasis
{
  groups  = rbasis;
#  add(doc)      = """ docu for all files """;
#  add(extra)    = """ @ref rbasis """;
#  add(params)   = plot_params => """ struct controlling plot output. E.g. a flag that enables or disables a colorbar can be set. """;
  glob = basisgen
  {
    groups = basisgen;
    glob = ei { groups = ei; }
  }
  glob = lin_evol { groups = lin_evol; }
  glob = nonlin_evol { groups = nonlin_evol; }
  glob = lin_ds { groups = lin_ds; }
}


glob = models
{
  groups = models;
  glob = advection_output { groups = advection_output; }
  glob = richards_fv_model.m { groups = richards_fv; }
  glob = *convdiff.m { groups = convdiff; }
  glob = common { groups = models_common; }
  glob = dune-rb { groups = dune_rb; }
}

glob = datafunc
{
  groups = datafunc;
  add(params) = params => """ a structure with model parameters """;
  glob = conv_flux
  {
    add(params) = glob => """ a matrix of row vectors for each coordinate
    dimension of the grid defining the coordinates where the flux function is
    evaluated, in case it is space dependent, i.e. we have something like
    `f(u,x)`.""";
    add(params) = U => """ a vector with evaluations of a solution `u` which
    are passed as an argument to the flux function `f`""";
    add(fields) = (
      params.conv_flux_ptr => """ the convective flux function `f : \mathbb{R}
      \to \mathbb{R}^d` of which the  derivative shall be computed. """
    );
    add(return) = flux => """ a matrix which entries `F_{ji}` represent the
    `i`-th component of the flux vector `f(u(x_{j}))` in
    the edge midpoint `x_{j}` given by the 'glob' argument. """;
    add(doc) = """ Convective flux functions are used e.g. by
    @ref fv "finite folume operators" like
    fv_operators_conv_explicit_lax_friedrichs() or
    fv_num_conv_flux_engquist_osher(). """;
    add(return) = lambda => """ a bound such that
             ``\lambda \cdot \sup_u n_{jl} \cdot f'(u) \leq 1``
            e.g. `\lambda := \frac{1}{\sup|v(x,y)|}` for `f(u) = v \cdot u`.
            This is value only reasonable in 'decomp_mode==0', otherwise an
            empty variable is returned. """;
  }
}

glob = discfunc
{
  groups = discfunc;
  glob = fv { groups = fv; }
  glob = ldg { groups = ldg; }
  glob = fem { groups = fem; add(params) = grid => """ an object of type triagrid """; }
}

glob = general
{
  groups = general;
  glob = vecmat { groups = vector; }
}

glob = demos { groups = demos; }
glob = test {
  add(return) = OK => """ boolean indicating wether test was successful """;
  groups = test;
}
glob = scripts { groups = scripts; }

glob = grid
{
  groups = grid;
  glob = */plot* { groups = visual; }
  glob = @rectgrid { groups = rectgrid; }
  glob = @cubegrid { groups = cubegrid; }
  glob = @triagrid { groups = triagrid; }
}


# vim: set ft=perl et sw=2 :
