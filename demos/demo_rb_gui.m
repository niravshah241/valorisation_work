function demo_rb_gui(varargin)
% function demo_rb_gui(model,detailed_data,[reduced_data],plot_params[,title, callbackfigure, cbhandle]) 
%
% RB-demo on prescribed grid specified in params-structure. if a
% title is specified, this is set as the figure Name. If further
% parameters are set, the call is assumed to stem from a callback-function
% if detailed_data, offline_data and params are empty, a default basis 
% is chosen from matlab/datafiles/
% if only detailed_data and params is specified, a offline_precomputation
% phase is performed.

% This program is open source.  For license terms, see the COPYING file.
%
% --------------------------------------------------------------------
% ATTRIBUTION NOTICE:
% This product includes software developed for the RBmatlab project at
% (C) Universities of Stuttgart and MÃ¼nster, Germany.
%
% RBmatlab is a MATLAB software package for model reduction with an
% emphasis on Reduced Basis Methods. The project is maintained by
% M. Dihlmann, M. Drohmann, B. Haasdonk, M. Ohlberger and M. Schaefer.
% For Online Documentation and Download we refer to www.morepas.org.
% --------------------------------------------------------------------


% Bernard Haasdonk 20.7.2006

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% open figure
if nargin < 6 % no callback,open new figure
  f = figure;
  ud = [];
  list = varargin;
  if nargin==0
    %    disp(['no arguments passed, so loading dummy reduced basis +' ...
    %         ' parameters']);
    %    disp('the basis is constructed from the upper range-parameters');    
    %    disp('so this is approximated particularly well, other parameters bad.');    
    %    fn = fullfile(rbmatlabhome,'tmpdata','dummy_reduced_basis.mat');
    %    tmp = load(fn);
    %    tmp.params.init_values_algorithm = 'init_values_cog';
    %    tmp.params.operators_algorithm = 'operators_conv_diff';
    %    tmp.params.lxf_lambda = 1.0194e+003;
    %    tmp.params.data_const_in_time = 1;
    %    tmp.params.T = 0.05;
    %    tmp.params.nt = 20;
    %    list{4}= ['RB suited for upper bounds' ...
    %             ' of parameters'];
    %    fn = fullfile(rbmatlabhome,'tmpdata','dummy_offline_data_const.mat');
    %    tmp = load(fn);
    %    list{2} = tmp.offline_data;
    disp(['no arguments passed, so loading default reduced basis +' ...
          ' parameters']);
    disp('the basis contains vectors generated by PCAfixspace ');    
    disp('on an equidistant 5x5x5 grid in the mu-range');    
    %    disp('guaranteeing the error estimator < 1e-7 on this grid ');    
    fn = fullfile(rbmatlabhome,'datafiles',...
                  'test_rb_lin_evol_data');
    %                  'demo_lin_evol_detailed_data.mat');
    %                 'RB_extension_PCA_fixspace_extended.mat');
    tmp = load(fn);
    list{2} = tmp.detailed_data;
    tmp.model.axis_tight = 1;
    %%%  the following will update the model, if fields have been missing:
    %    update_model_and_save_to_file = 1;
    update_model_and_save_to_file = 0;
    if update_model_and_save_to_file
      model = lin_evol_model_default;  
      model = structcpy(model, tmp.model);
      detailed_data = tmp.detailed_data;
      save(fn,'model','detailed_data');
      disp('transformed precomputed datafile successful');
      tmp.model = model;
      clear('detailed_data','model')
    end;
    list{1} = tmp.model;
    list{5}= ['RB of ',num2str(size(tmp.detailed_data.RB,2)), ...
              ' vectors obtained by PCAfixspace'];
  end;
  %    keyboard;
  if nargin <3
    list{3} = [];
  end;
  if nargin <4
    list{4} = [];
  end;
  if nargin <5
    list{5} = ['RB Demo GUI'];
  end;
  
  ud.model = list{1};
  if isstruct(list{2})
    ud.detailed_data = list{2};
  end;
  if ~isfield(ud.model,'N')
    ud.model.N = ceil(ud.model.get_rb_size(ud.model,ud.detailed_data)/2);
  end;
    
  if ~isfield(ud.model,'using_empirical_interpolation')
    ud.model.using_empirical_interpolation = 0;
    if isfield(ud.detailed_data,'QM')
      ud.model.using_empirical_interpolation = 1;
    end;
  end;
  if ud.model.using_empirical_interpolation
%    if ~isfield(ud.model,'M')

      ud.model.Mmax = cellfun(@(x) size(x,2), ud.detailed_data.QM, 'UniformOutput', true);
ud.model.M;
      ud.model.M = ceil(0.5*ud.model.Mmax);
      ud.model.Mratio = 0.5;
      ud.model.Mstrich = 0;
%    end;
  end;
 
  if ~isfield(ud.model,'is_stationary')
    ud.model.is_stationary = 0; % for evolution problems
  end;
  
  ud.plot_params = list{4};
  if isempty(ud.plot_params)
    % copy some fields from model
    if isfield(ud.model,'yscale_uicontrols')
      ud.plot_params.yscale_uicontrols = ud.model.yscale_uicontrols;
    end;
    if isfield(ud.model,'xscale_gui');
      ud.plot_params.xscale_gui = ud.model.xscale_gui;
    end;
    if isfield(ud.model,'clim');
      ud.plot_params.clim = ud.model.clim;
    end;
    if isfield(ud.model,'show_colorbar');
      ud.plot_params.show_colorbar = ud.model.show_colorbar;
    end;
    if isfield(ud.model,'geometry_transformation');
      ud.plot_params.geometry_transformation = ud.model.geometry_transformation;
    end;
  end;
  
  
%  ud.grid = ud.detailed_data.grid;
  if isempty(list{3})
    disp('Preparing offline-quantities...')
    %      keyboard;
    ud.reduced_data = gen_reduced_data(ud.model, ud.detailed_data);
  else 
    ud.reduced_data = list{3};
  end;
  if length(list)>4;
    set(f,'Name',list{5});
  end;
  ud.timestep = 0;
  set(f,'Userdata',ud);
  %    disp(['set userdata to fig ',num2str(f)]);
  %  else
    %    disp(['userdata is not set to fig ',num2str(f)]);
    %end;
  
  if ~isfield(ud.model, 'geometry_transformation')
    ud.model.geometry_transformation = 'none';
  end
  
  di = 0.05; % relative distance between gui_objects
  textwidth= 0.15;
  textheight = 0.05;
  yscale_uicontrols = 1.0;
  xscale_gui = 1.0;
  
  if isfield(ud.plot_params,'yscale_uicontrols')
    yscale_uicontrols = ud.plot_params.yscale_uicontrols;
  end;
  if isfield(ud.plot_params,'xscale_gui')
    xscale_gui = ud.plot_params.xscale_gui;
  end;

  % xscale gui
  p = get(gcf,'Position');
  p(3) = p(3) * xscale_gui;
  set(gcf,'Position',p);
  
  % create one txt and slider for each mu_name
  for i=1:length(ud.model.mu_names)
    % set mu-param-values to minimum of ranges as the position of a
    % slider does not seem to be adjustable
    tmprange = cell2mat(ud.model.mu_ranges);
    ud.model = ud.model.set_mu(ud.model,tmprange(1:2:end));
    mu = ud.model.get_mu(ud.model);
    val = mu(i);
    %val = ud.model.(ud.model.mu_names{i});
    ra = ud.model.mu_ranges{i};
    norm_val = (val-ra(1))/(ra(2)-ra(1));
    txt(i) = uicontrol(f,'Style','text','Units','normalized',...
                       'Position',...
                       [di,(i*di+(i-1)*textheight)*yscale_uicontrols,...
                        textwidth,textheight*yscale_uicontrols],...
                       'String',[ud.model.mu_names{i},'=',num2str(val)],...
                       'Tag',['text_',ud.model.mu_names{i}]);
    slider(i) = uicontrol(f,'Style','slider','Units','normalized',...
                          'Position',...
                          [ 2*di+textwidth, ...
                          (i*di+(i-1)*textheight)*yscale_uicontrols, ...
                          1-3*di-textwidth,...
                          textheight*yscale_uicontrols],...
                          'Tag',['slider_',ud.model.mu_names{i}],...
                          'Min',0, ...
                          'Max',1, ...
                          'value',norm_val, ...                   
                          'Callback','demo_rb_gui([],[],[],[],[], gcbf,gcbo)');
    %                     'Min',ud.model.mu_ranges{i}(1), ...
%                         'Max',ud.model.mu_ranges{i}(2), ...

  end;
  set(f,'Userdata',ud);

  % N = number of RB slider
  i = length(ud.model.mu_names)+1;
  txt(i) = uicontrol(f,'Style','text','Units','normalized',...
                     'Position', ...
                     [di,(i*di+(i-1)*textheight)*yscale_uicontrols,...
                      textwidth,textheight*yscale_uicontrols],...
                     'String',['RB-size N = ',num2str(ud.model.N)],...
                     'Tag','text_N');
  slider(i) = uicontrol(f,'Style','slider','Units','normalized',...
                        'Position',...
                        [2*di+textwidth, ...
                        (i*di + (i-1)*textheight)*yscale_uicontrols, ...
                        1-3*di-textwidth,textheight*yscale_uicontrols],...
                        'Tag','slider_N',...
                        'min',1,'max', ...
                        ud.model.get_rb_size(ud.model,ud.detailed_data),...
 			'value',ud.model.N, ...
                        'Callback','demo_rb_gui([],[],[],[],[],gcbf,gcbo)',...
                        'sliderstep',...
			[1/((ud.model.get_rb_size(ud.model,ud.detailed_data))-1),0.1]);
  
  
  % M = number of CRB slider
%  if isequal(ud.model.rb_problem_type,'nonlin_evol')...
%          || isequal(ud.model.rb_problem_type,'richards')
   if ud.model.using_empirical_interpolation
    i = length(ud.model.mu_names)+2;
    txt(i) = uicontrol(f,'Style','text','Units','normalized',...
                       'Position', ...
                       [di,(i*di+(i-1)*textheight)*yscale_uicontrols,...
                        textwidth,textheight*yscale_uicontrols],...
                       'String',['CRB-size M = ',num2str(ud.model.Mratio)],...
                       'Tag','text_M');
    slider(i) = uicontrol(f,'Style','slider','Units','normalized',...
                          'Position',...
                          [2*di+textwidth, ...
                          (i*di + (i-1)*textheight)*yscale_uicontrols, ...
                          1-3*di-textwidth,textheight*yscale_uicontrols],...
                          'Tag','slider_M',...
                          'min',0,'max',1,'value',...
                          ud.model.Mratio, ...
                          'Callback','demo_rb_gui([],[],[],[],[],gcbf,gcbo)',...
                          'sliderstep',[1/(size(ud.detailed_data.QM{1},2)-1),0.1]);
  end; % if nonlin-evol
  
  % time slider
  if ~ud.model.is_stationary
    i = i+1;  %length(ud.params.mu_names)+2; % or +3 if M-slider available!
    txt(i) = uicontrol(f,'Style','text','Units','normalized',...
		       'Position', ...
		       [di,(i*di+(i-1)*textheight)*yscale_uicontrols,...
			textwidth,textheight*yscale_uicontrols],...
		       'String','timestep 0','Tag','text_time');
    slider(i) = uicontrol(f,'Style','slider','Units','normalized',...
			  'Position',...
			  [2*di+textwidth, ...
		    (i*di + (i-1)*textheight)*yscale_uicontrols, ...
		    1-3*di-textwidth,textheight*yscale_uicontrols],...
			  'Tag','slider_time',...
			  'min',0,'max',ud.model.nt,'value',0, ...
			  'Callback','demo_rb_gui([],[],[],[],[],gcbf,gcbo)',...
			  'sliderstep',[1/ud.model.nt,0.1]);
  end;
  % graphics axes
  ax = axes('Units','normalized',...
            'Position',[di,((i+2)*di+i*textheight)*yscale_uicontrols,...
                    1-2*di,1-((i+3)*di + i*textheight)*yscale_uicontrols],...
            'Tag','axes1');

  %  cb = colorbar;

%  sl = findobj(f,'Tag','slider1');
  %set(sl,'min',0);
  %set(sl,'max',ud.params.nt);
  %set(sl,'sliderstep',[1/ud.params.nt,1]);
%  set(sl,'min',1);
%  if size(ud.U,2)>1
%    set(sl,'max',size(ud.U,2));
%    set(sl,'sliderstep',[1/(size(ud.U,2)-1),1]);
%  else
%    set(sl,'max',size(ud.U,2)+eps);
%    set(sl,'visible','off');
%    %  set(sl,'sliderstep',[0,0]);
%  end;
%  set(sl,'value',1);
%  th = findobj(f,'Tag','text1');
%  set(th,'String',['data slice 1']);
  replot(f,'new');
%  set(f,'Resize','on');  
end; % nargin < 6

if nargin >=6 % callback-function
  cbf = varargin{6};
  cbo = varargin{7};
  ud = get(cbf,'Userdata');
%  disp('performing callback call of plot_fv_data');
  % set new parameters in ud.params
  tag = get(cbo,'Tag');
  if isequal(tag,'slider_time')
    val = round(get(cbo,'value'));
    set(cbo,'value',val);
%    disp('check value of timestep!');
%    keyboard;
    ud.timestep = val;
    txt = findobj(cbf,'Tag','text_time');
    set(txt,'String',['timestep = ',num2str(val)]);
    sourcestr = 'time';
  elseif isequal(tag,'slider_N')
    val = round(get(cbo,'value'));
    set(cbo,'value',val);
    ud.model.N = val;
    txt = findobj(cbf,'Tag','text_N');
    set(txt,'String',['RB-size N = ',num2str(val)]);
    sourcestr = 'N';
  elseif isequal(tag,'slider_M')
    val = get(cbo,'value');
    set(cbo,'value',val);
    ud.model.M = ceil(val * ud.model.Mmax);
    txt = findobj(cbf,'Tag','text_M');
    set(txt,'String',['CRB-size M = ',num2str(val)]);
    sourcestr = 'M';
  else
    found_cbo = 0;
    for i=1:length(ud.model.mu_names)
      if isequal(tag,['slider_',ud.model.mu_names{i}])
%       keyboard;
        found_cbo = 1;
        val = get(cbo,'value')*...
                  (ud.model.mu_ranges{i}(2)-...
                   ud.model.mu_ranges{i}(1)) + ... 
                   ud.model.mu_ranges{i}(1);

	mu = ud.model.get_mu(ud.model);
	mu(i) = val;
	ud.model = ud.model.set_mu(ud.model,mu);
%        ud.model.(char(ud.model.mu_names(i))) = val;

        txt = findobj(cbf,'Tag',['text_',ud.model.mu_names{i}]);
        set(txt,'String',[ud.model.mu_names{i},' = ',num2str(val)]);
        sourcestr = 'mu';
      end;
    end;
    if ~found_cbo
      error('callback object unknown!!');
    end;
  end;
  set(cbf,'Userdata',ud);
  %  th = findobj(gcbf,'Tag','text1');
  %  v = round(get(gcbo,'value'));
  %  set(gcbo,'value',v)
  %  set(th,'String',['data slice ',num2str(v)]);
  replot(cbf,sourcestr);
end;

function replot(f,tag)
ud = get(f,'Userdata');

%if isequal(ud.model.rb_problem_type,'lin_evol') || ...
%	(isequal(ud.model.rb_problem_type,'nonlin_evol') && ...
if  isfield(ud.model,'enable_error_estimator') && ...
      ud.model.enable_error_estimator
  enable_error_estimator = 1;
else
  enable_error_estimator = 0;
end

% if required perform new RB simulation

if ismember(tag,{'new','mu','N','M'})
  % in our problem the two bounds can be chosen 1
%  ud.model.L_I_inv_norm_bound = 1;
%  ud.model.L_E_norm_bound = 1;
  ud.model.error_norm = 'l2';
  
  % no affine decomposition: complete mu-dependent matrices are computed
  %ud.params.decomp_mode = 0; 
  % in case of 0, the mu must be set reasonably in advance, as the
  % current parameters are used.
  
  % compute offline-data (mu-independent!)
  %offline_data = rb_offline_preparation(ud.RB,ud.grid,ud.params);
  
%  mu = [];
%  for i=1:length(ud.model.mu_names)
%    mu = [mu, ud.model.(ud.model.mu_names{i})];
%  end;
   mu = ud.model.get_mu(ud.model);
  % prepare mu-independent but N-dependent online-data
  %ud.params.N = size(ud.detailed_data.RB,2);
%  if isequal(ud.model.rb_problem_type,'nonlin_evol') || ...
%      isequal(ud.model.rb_problem_type,'richards')
  if ud.model.using_empirical_interpolation
     disp(['performing RB simulation with N = ',num2str(ud.model.N),...
          ', M = ', num2str(ud.model.M),...
          ' for mu = [',num2str(mu(:)'),']']);
  else
    disp(['performing RB simulation with N = ',num2str(ud.model.N),...
          ' for mu = [',num2str(mu(:)'),']']);
  end;
  reduced_data = extract_reduced_data_subset(ud.model,ud.reduced_data);
  
  % perform RB-simulation
  ud.model = ud.model.set_mu(ud.model,mu);

  simulation_data = rb_simulation(ud.model,reduced_data);
  
  rb_sim_data=rb_reconstruction(ud.model,ud.detailed_data,simulation_data);
  % please remove later this U explicitly, instead use ud.sim_data;
  %U = ud.model.get_dofs_from_sim_data(rb_sim_data);
  ud.sim_data = rb_sim_data;
  if enable_error_estimator
    ud.Delta = ud.model.get_estimators_from_sim_data(simulation_data);
    if isfield(simulation_data,'reslog')
      ud.reslog = simulation_data.reslog;
      ud.eilog = simulation_data.eilog;
    end;
  end;
  if isfield(ud.model,'name_output_functional')
    ud.s = simulation_data.s;
    if enable_error_estimator
      ud.Delta_s = simulation_data.Delta_s;
    end;
  end;
  if ~isfield(ud.plot_params,'clim')
    U = ud.model.get_dofs_from_sim_data(rb_sim_data);
    ud.cmin = min(min(U));
    ud.cmax = max(max(U));
    if (ud.cmin==ud.cmax)
      ud.cmin = ud.cmin-eps;
      ud.cmax = ud.cmax+eps;
    end;
    clear('U');
  else
    ud.cmin = ud.plot_params.clim(1);
    ud.cmax = ud.plot_params.clim(2);
  end
  set(f,'Userdata',ud);
  
end;

% plot current slice;

if enable_error_estimator
  disp(['error_estimator Delta(',num2str(ud.timestep),') = ',...
        num2str(ud.Delta(ud.timestep+1))]);
  if isfield(ud.model,'name_output_functional')
    disp(['output-estimator s(U(',num2str(ud.timestep),')) = ',...
          num2str(ud.s(ud.timestep+1))]);
    disp(['output-error-estimator Delta_s(',num2str(ud.timestep),...
          ') = ', num2str(ud.Delta_s(ud.timestep+1))]);
  end;
  if isfield(ud,'reslog')
    disp(['error_estimator reslog(',num2str(ud.timestep),') = ',...
	  num2str(ud.reslog(ud.timestep+1))]);
    disp(['error_estimator eilog(',num2str(ud.timestep),') = ',...
	  num2str(ud.eilog(ud.timestep+1))]);
    
  end;
end;
fprintf('plotting...');
% in the following we use pcolor as builtin, as it is faster... 
%  for non-cartesian grids, the plot_element_data function must be used...
ax = findobj(f,'Tag','axes1');
cla(ax);
% ud.plot_params is an overlay to the default plot data of the model
% not only in case of "bind to model", but always:
ud.plot_params = merge_model_plot_params(ud.model,ud.plot_params);
%if isfield(ud.plot_params, 'bind_to_model') && ud.plot_params.bind_to_model
%  ud.plot_params = copy_model_data_to_plot_params(ud.model, ...
%                                                  ud.plot_params);
%end
if ~isfield(ud.plot_params,'axis_equal')
    ud.plot_params.axis_equal = 1;
end;
if isequal(ud.model.gridtype,'rectgrid') ...
    && ( ~isfield(ud.plot_params, 'geometry_transformation') || ...
         isequal(ud.plot_params.geometry_transformation, 'none') )
  U = ud.model.get_dofs_from_sim_data(ud.sim_data);
  d = reshape(U(:,ud.timestep+1),...
              ud.model.xnumintervals,ud.model.ynumintervals)';
  xr = ud.model.xrange;
  x = xr(1):(xr(2)-xr(1))/(ud.model.xnumintervals):xr(2);
  yr = ud.model.yrange;
  y = yr(1):(yr(2)-yr(1))/(ud.model.ynumintervals):yr(2);
  p=pcolor(x,y,[d,zeros(size(d,1),1);zeros(1,size(d,2)+1)]);
else
  if isequal(ud.model.geometry_transformation, 'none') && ...
    ~isfield(ud.plot_params,'no_lines')
    ud.plot_params.no_lines = 1;
  end
  % must be set externally, if wanted:
  %  ud.params.show_colorbar = 1;

  if ud.model.is_stationary
    p = ud.model.plot_sim_data(ud.model,...
		      ud.detailed_data, ...
		      ud.sim_data, ...
		      ud.plot_params);    
  else % evolution problem
    if isfield(ud.plot_params,'plot_slice')
      % timestep in range 0... nt!!
      ud.plot_params.timestep = ud.timestep;
      p = ud.plot_params.plot_slice(ud.model,...
				    ud.detailed_data, ...
				    ud.sim_data, ...
				    ud.plot_params);    
    else
      U = ud.model.get_dofs_from_sim_data(ud.sim_data);
      p = ud.plot_params.plot(ud.detailed_data.grid,...
                              U(:,ud.timestep+1), ...
              			      ud.plot_params);
    end;
  end;
  
end;
ax = gca;
if ud.plot_params.axis_equal;
  axis equal;
end;
if isfield(ud.plot_params,'axis_tight') && ud.plot_params.axis_tight
  axis tight;
end;
if isfield(ud.plot_params,'clim')
  set(ax,'Clim',ud.plot_params.clim);  
else
  set(ax,'Clim',[ud.cmin, ud.cmax]);
end;
ax2 = ax;
if isfield(ud.plot_params,'show_colorbar') && (ud.plot_params.show_colorbar)
  if isfield(ud.plot_params,'colorbar_mode') 
    colorbar(ud.plot_params.colorbar_mode);
  else
    colorbar;
  end;
  ax2 = gca;
end;
if isfield(ud.plot_params,'no_lines') && (ud.plot_params.no_lines)
  set(p,'LineStyle','None');
end;
fprintf('done\n');
%keyboard;

%| \docupdate 
